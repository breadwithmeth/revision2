# Анализ одновременной работы с нескольких ТСД

## Текущая реализация (Optimistic Locking)

### Сценарий конфликта:
1. **ТСД-1** читает документ (version: 1)
2. **ТСД-2** читает документ (version: 1)
3. **ТСД-1** обновляет товар A → version: 2
4. **ТСД-2** пытается обновить товар B с version: 1 → **409 Conflict**

### Проблемы:
- ТСД-2 теряет свои изменения
- Пользователь должен перечитать документ и повторить ввод
- Неудобно при работе большой команды

## Улучшенная реализация (v2 API)

### Стратегия разрешения конфликтов:

1. **Document-level versioning** - защита от одновременного revise
2. **Row-level timestamps** - отслеживание изменений каждой строки
3. **Smart merge** - автоматическое слияние несконфликтующих изменений
4. **Conflict reporting** - информирование о конфликтах с возможностью принятия решения

### Алгоритм работы:

```
PATCH /inventory-documents/:id/items/v2
{
  "version": 1,
  "deviceId": "TSD-001", 
  "items": [
    {
      "sku": "ITEM001",
      "countedQty": "95",
      "lastKnownModified": "2025-08-20T10:30:00Z"
    }
  ]
}
```

**Шаги обработки:**
1. Проверяем версию документа (документ не должен быть в revise)
2. Для каждой строки сравниваем `lastKnownModified` с `updatedAt` в БД
3. Если timestamps совпадают → применяем изменения
4. Если не совпадают → фиксируем конфликт, но все равно применяем (Last Writer Wins)
5. Возвращаем результат с информацией о конфликтах

**Возможные ответы:**

**200 OK** - все изменения применены без конфликтов:
```json
{
  "success": true,
  "version": 2,
  "conflicts": [],
  "appliedChanges": 3
}
```

**206 Partial Content** - есть конфликты, но изменения применены:
```json
{
  "success": true,
  "version": 2,
  "appliedChanges": 2,
  "conflicts": [
    {
      "sku": "ITEM001",
      "field": "countedQty",
      "yourValue": "95", 
      "currentValue": "98",
      "lastModified": "2025-08-20T10:35:00Z",
      "modifiedBy": "TSD-002"
    }
  ]
}
```

## Практические сценарии

### Сценарий 1: Разные товары
✅ **Безконфликтная работа**
- ТСД-1 редактирует товар A
- ТСД-2 редактирует товар B
- Оба изменения применяются успешно

### Сценарий 2: Один товар, разные поля
✅ **Безконфликтная работа**
- ТСД-1 устанавливает `countedQty`
- ТСД-2 устанавливает `note`
- Оба изменения применяются

### Сценарий 3: Один товар, одно поле
⚠️ **Конфликт с автоматическим разрешением**
- ТСД-1 устанавливает `countedQty: "95"`
- ТСД-2 устанавливает `countedQty: "98"`
- Побеждает последний (Last Writer Wins)
- ТСД-1 получает уведомление о конфликте

### Сценарий 4: Попытка revise во время редактирования
❌ **Блокировка на уровне документа**
- Любые изменения строк инкрементируют версию документа
- Revise возможен только со статусом IMPORTED
- Optimistic locking защищает от некорректного revise

## Рекомендации по использованию

### Для ТСД приложения:
1. Используйте API v2 для лучшего UX
2. Показывайте пользователю информацию о конфликтах
3. Периодически синхронизируйтесь с сервером
4. Передавайте `deviceId` для лучшего отслеживания

### Для UI:
```javascript
// Пример обработки конфликтов в ТСД
const result = await updateItems(documentId, changes);

if (result.conflicts.length > 0) {
  showConflictDialog(result.conflicts);
  // Предложить пользователю: 
  // - Принять текущие значения
  // - Перезаписать своими
  // - Отменить операцию
}
```

### Мониторинг:
- Логируйте все конфликты для анализа
- Отслеживайте частоту конфликтов по складам
- Анализируйте паттерны работы команд

## Будущие улучшения

1. **Real-time notifications** - WebSocket уведомления об изменениях
2. **Field-level locking** - временная блокировка полей при редактировании  
3. **Collaborative editing** - показ кто сейчас редактирует строку
4. **Conflict resolution policies** - настраиваемые стратегии разрешения конфликтов
